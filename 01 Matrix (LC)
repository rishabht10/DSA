class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        int n = mat.size(); 

	    int m = mat[0].size(); 
        int size,steps=0;
	    // visited and distance matrix

	    vector<vector<int>> vis(n, vector<int>(m, 0)); 

	    vector<vector<int>> dist(n, vector<int>(m, 0)); 

	    // <coordinates, steps>

	    queue<pair<pair<int,int>, int>> q; 

	    // traverse the matrix

	    for(int i = 0;i<n;i++) {

	        for(int j = 0;j<m;j++) {

	            // start BFS if cell contains 1

	            if(mat[i][j] == 0) {

	                q.push({{i,j}, 0}); 

	                vis[i][j] = 1; 

	            }

	            else {

	                // mark unvisited 

	                vis[i][j] = 0; 

	            }

	        }

	    }

	    

	    int delrow[] = {-1, 0, +1, 0}; 

	    int delcol[] = {0, +1, 0, -1}; 

	    

	    // traverse till queue becomes empty

	    while(!q.empty()) {
  size=q.size();
            while(size){
	        int row = q.front().first.first; 

	        int col = q.front().first.second; 

	        //int steps = q.front().second; 

	        q.pop(); 

	        dist[row][col] = steps; 

	        // for all 4 neighbours

	        for(int i = 0;i<4;i++) {

	            int nrow = row + delrow[i]; 

	            int ncol = col + delcol[i]; 

	            // check for valid unvisited cell

	            if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < m 

	            && vis[nrow][ncol] == 0 && mat[nrow][ncol]==1) {

	                vis[nrow][ncol] = 1; 

	                q.push({{nrow, ncol},1});  

	            }

	        }
                size--;
                }
            steps++;

	    }

	    // return distance matrix

	    return dist; 
    }
};
